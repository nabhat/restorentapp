package com.proj.customerservice.entity;

import java.time.LocalDateTime;

import org.slf4j.Logger;
import org.slf4j.LoggerFactory;

import jakarta.persistence.Entity;
import jakarta.persistence.FetchType;
import jakarta.persistence.GeneratedValue;
import jakarta.persistence.GenerationType;
import jakarta.persistence.Id;
import jakarta.persistence.JoinColumn;
import jakarta.persistence.ManyToOne;
import jakarta.persistence.Table;
import jakarta.validation.constraints.NotNull;
import jakarta.validation.constraints.Positive;
import lombok.AllArgsConstructor;
import lombok.Data;
import lombok.NoArgsConstructor;

/**
 * Orders is an entity class that represents an order placed by a customer in the application.
 * 
 * This class maps to the "orders" table in the database and contains fields that store
 * details about the order, including the dish ID, quantity, and the associated customer.
 * 
 * Key Fields:
 * - orderId: The unique identifier for the order. It is auto-generated using the IDENTITY strategy.
 * - dishId: The ID of the dish being ordered. It is annotated with @NotNull to ensure that this field
 *   cannot be null and must be provided.
 * - quantity: The quantity of the dish being ordered. This field is validated to be positive and non-null.
 * - customer: A many-to-one relationship with the Customer entity, representing the customer who placed the order.
 * 
 * This class is annotated with @Entity, meaning it is managed by JPA and mapped to a database table.
 * The validation annotations ensure that the dish ID and quantity are valid when persisted.
 * 
 * Lombok annotations (@AllArgsConstructor, @NoArgsConstructor, @Data) are used to automatically generate 
 * boilerplate code such as constructors, getters, setters, and equals/hashCode methods, simplifying the code base.
 */
@AllArgsConstructor
@NoArgsConstructor
@Data
@Entity
@Table(name = "orders")
public class Orders {
    @Id
    @GeneratedValue(strategy = GenerationType.IDENTITY)
    private Integer orderId; // Unique identifier for each order, generated by the database
    
    @NotNull(message = "dish Id can't be empty")
    private Integer dishId;// The ID of the dish being ordered, must not be null
    @NotNull(message = "Quantiy can't be empty")
    @Positive	// Ensures that the quantity is a positive number
    private Integer quantity; // The number of dishes ordered, must be positive and non-null
    private LocalDateTime ordertime;
    private Integer status;
    @ManyToOne(fetch = FetchType.EAGER)
    @JoinColumn(name = "customer")// Foreign key linking the order to the customer
    private Customer customer;// The customer who placed the order
    
 // Logger for logging any relevant information about orders
    private static final Logger logger = LoggerFactory.getLogger(Orders.class);

    /**
     * Logs the creation of a new order.
     */
    public void logOrderCreation() {
        logger.info("New order created with orderId: {}, dishId: {}, quantity: {}, customerId: {}", 
                    this.orderId, this.dishId, this.quantity, this.customer.getCustomerId());
    }

    /**
     * Logs any error related to the order.
     *
     * @param message the error message to log
     */
    public void logOrderError(String message) {
        logger.error("Order error: {}", message);
    }
}
